EN

You are tasked with implementing a dynamic jagged array (an array of arrays where each inner array can have a different size) using only raw pointers and dynamic memory allocation functions. The main challenge is to manage both the collection of arrays (rows) and the individual arrays themselves dynamically, without the aid of structures or user-defined types. This problem demands precise understanding of pointer arithmetic, pointer to pointer concepts, and robust memory management practices.

The core task involves creating a C program that simulates operations on such a jagged array. You must initialize an array of `int*` pointers, where each `int*` points to a dynamically allocated array of integers. Both the number of `int*` pointers (rows) in the main collection and the size of each individual `int` array (column count for a specific row) must be dynamic and mutable. Your solution must demonstrate the ability to add new rows, remove existing rows, and resize specific rows, all while maintaining data integrity and preventing memory leaks or access violations.

Your C solution must demonstrate the following sequence of operations within the `main` function: initial allocation of a jagged array with a few rows of varying sizes; adding a new row to the existing collection (which involves reallocating the main `int**` pointer and its corresponding row size metadata); resizing an existing row (reallocating a specific `int*` pointer); and removing a row (freeing the specific row, shifting subsequent rows, and reallocating the main `int**` and its metadata). Throughout these operations, you must handle memory carefully using `malloc`, `realloc`, and `free`, ensuring all allocated memory is properly released at the program's conclusion. Error handling for `malloc` and `realloc` failures (e.g., checking for `NULL` returns) is crucial and expected for a robust HARD-level solution.

TR

Sizden, yalnızca ham işaretçiler ve dinamik bellek tahsis fonksiyonları kullanarak dinamik bir dişli dizi (her bir iç dizinin farklı boyutta olabileceği bir dizi dizisi) uygulamanız istenmektedir. Ana zorluk, yapılar veya kullanıcı tanımlı tiplerin yardımı olmadan, hem dizi koleksiyonunu (satırları) hem de tek tek dizilerin kendilerini dinamik olarak yönetmektir. Bu problem, işaretçi aritmetiği, işaretçinin işaretçisi kavramları ve sağlam bellek yönetimi uygulamaları hakkında hassas bir anlayış gerektirmektedir.

Temel görev, böyle bir dişli dizi üzerinde işlemleri simüle eden bir C programı oluşturmaktır. Her bir `int*` işaretçisinin dinamik olarak tahsis edilmiş bir tam sayı dizisine işaret ettiği bir `int*` işaretçi dizisi başlatmalısınız. Hem ana koleksiyondaki `int*` işaretçi sayısı (satır sayısı) hem de her bir `int` dizisinin boyutu (belirli bir satır için sütun sayısı) dinamik ve değiştirilebilir olmalıdır. Çözümünüz, yeni satırlar ekleme, mevcut satırları kaldırma ve belirli satırları yeniden boyutlandırma yeteneğini, tüm bunlar veri bütünlüğünü korurken ve bellek sızıntılarını veya erişim ihlallerini önlerken göstermelidir.

C çözümünüz, `main` fonksiyonu içinde aşağıdaki işlem dizisini göstermelidir: değişken boyutlarda birkaç satıra sahip bir dişli dizinin başlangıç tahsisi; mevcut koleksiyona yeni bir satır ekleme (ana `int**` işaretçisinin ve buna karşılık gelen satır boyutu meta verilerinin yeniden tahsisini içeren); mevcut bir satırı yeniden boyutlandırma (belirli bir `int*` işaretçisini yeniden tahsis etme); ve bir satırı kaldırma (belirli satırı serbest bırakma, sonraki satırları kaydırma ve ana `int**` ile meta verilerini yeniden tahsis etme). Bu işlemler boyunca, `malloc`, `realloc` ve `free` kullanarak belleği dikkatli bir şekilde yönetmeli, programın sonunda tüm tahsis edilen belleğin düzgün bir şekilde serbest bırakıldığından emin olmalısınız. `malloc` ve `realloc` hataları için hata işleme (örneğin, `NULL` dönüşlerini kontrol etme) sağlam bir ZOR seviye çözümü için çok önemlidir ve beklenmektedir.