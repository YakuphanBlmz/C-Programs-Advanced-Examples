EN

This problem challenges you to implement robust dynamic memory management for a two-dimensional integer matrix without relying on `struct` or `typedef` keywords. You will be working directly with `int**` pointers, `malloc`, `realloc`, and `free` to create, modify, and destroy a matrix where both its rows and columns can be dynamically resized at runtime.

You are required to implement several core functions: one to initialize a dynamic matrix, another to release all its allocated memory, and critical functions for adding and deleting both rows and columns at arbitrary indices. When a row or column is added, existing elements should be shifted to accommodate the new entry, and the new cells should be initialized to zero. Similarly, when a row or column is deleted, subsequent elements must be shifted to fill the gap, and the memory for the deleted row/column must be properly freed. The base pointer of the matrix or the dimension variables might change as a result of `realloc` operations, so careful handling of pointer-to-pointer and pass-by-reference for dimensions is crucial.

Your solution must demonstrate a deep understanding of pointer arithmetic, dynamic memory allocation patterns, and the lifecycle of dynamically allocated memory blocks. Particular attention should be paid to preventing memory leaks, avoiding dangling pointers, and handling potential `realloc` failures. The challenge is amplified by the constraint of not using `struct` or `typedef`, forcing a direct manipulation of raw pointers and primitive types to manage complex data structures.

TR

Bu problem, `struct` veya `typedef` anahtar kelimelerine başvurmadan iki boyutlu bir tamsayı matrisi için sağlam dinamik bellek yönetimini uygulamanızı zorlamaktadır. Çalışma zamanında hem satırları hem de sütunları dinamik olarak yeniden boyutlandırılabilen bir matris oluşturmak, değiştirmek ve yok etmek için doğrudan `int**` işaretçileri, `malloc`, `realloc` ve `free` ile çalışacaksınız.

Bir dinamik matrisi başlatmak, ayrılan tüm belleği serbest bırakmak ve rastgele indekslerde hem satır hem de sütun ekleyip silmek için kritik işlevler de dahil olmak üzere çeşitli temel işlevleri uygulamanız gerekmektedir. Bir satır veya sütun eklendiğinde, yeni girişi barındırmak için mevcut elemanlar kaydırılmalı ve yeni hücreler sıfıra başlatılmalıdır. Benzer şekilde, bir satır veya sütun silindiğinde, boşluğu doldurmak için sonraki elemanlar kaydırılmalı ve silinen satır/sütun için bellek düzgün bir şekilde serbest bırakılmalıdır. Matrisin temel işaretçisi veya boyut değişkenleri, `realloc` işlemleri sonucunda değişebileceğinden, işaretçinin işaretçisi ve boyutlar için referans ile geçişin dikkatli bir şekilde ele alınması çok önemlidir.

Çözümünüz, işaretçi aritmetiği, dinamik bellek ayırma kalıpları ve dinamik olarak ayrılmış bellek bloklarının yaşam döngüsü hakkında derin bir anlayış sergilemelidir. Bellek sızıntılarını önlemeye, başıboş işaretçilerden kaçınmaya ve olası `realloc` hatalarını ele almaya özellikle dikkat edilmelidir. `struct` veya `typedef` kullanmama kısıtlaması, karmaşık veri yapılarını yönetmek için ham işaretçilerin ve ilkel türlerin doğrudan manipülasyonunu zorunlu kılarak zorluğu artırmaktadır.