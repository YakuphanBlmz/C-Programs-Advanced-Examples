EN

In C programming, mastering dynamic memory management, especially with multi-level pointers, is crucial for handling flexible data structures. This problem challenges you to implement a dynamic 'container' of dynamic 'bags', where both the main container and each individual bag can grow dynamically as needed. The catch: you are strictly forbidden from using `struct`, `typedef`, or `file I/O`, pushing you to manage all related data (pointers, sizes, capacities) using only basic types and parallel arrays.

Your task is to create a system that simulates a collection of integer lists. The primary collection, let's call it the 'main container', will hold pointers to various 'sub-containers' or 'bags'. Each 'bag' itself is a dynamically allocated array of integers. Since you cannot use `struct` to bundle a pointer with its size and capacity, you must maintain separate, parallel dynamic arrays to track the `current_size` and `current_capacity` for each sub-container, as well as for the main container itself. This means you will effectively be managing an `int**` for the main container, along with two corresponding `int*` arrays for its metadata.

Specifically, your program should demonstrate the following: First, initialize the main container with an initial capacity to hold pointers to sub-containers, allocating memory for the `int**` and its two parallel metadata `int*` arrays. Second, implement logic to dynamically add new, empty sub-containers to the main container. This operation must handle resizing the `int**` (and its metadata arrays) using `realloc` if the main container reaches its capacity. Each new sub-container should be initialized as an empty `int*` array with its own initial capacity. Third, implement logic to add an integer value to a specified sub-container. This operation must also perform `realloc` on the target `int*` array if it reaches its capacity. Finally, display the contents of all sub-containers, showing their current size and capacity, and then meticulously free all dynamically allocated memory to prevent any leaks.

TR

C programlamada, özellikle çok seviyeli işaretçilerle dinamik bellek yönetimine hakim olmak, esnek veri yapılarını ele almak için çok önemlidir. Bu problem, hem ana kapsayıcının hem de her bir tekil 'çantanın' gerektiğinde dinamik olarak büyüyebildiği, dinamik 'çanta'ların dinamik bir 'kapsayıcısını' uygulamanızı gerektirir. Önemli kısıtlama: `struct`, `typedef` veya `dosya G/Ç` kullanmanız kesinlikle yasaktır, bu da tüm ilgili verileri (işaretçiler, boyutlar, kapasiteler) yalnızca temel türler ve paralel diziler kullanarak yönetmenizi zorunlu kılar.

Göreviniz, bir tamsayı listeleri koleksiyonunu simüle eden bir sistem oluşturmaktır. Birincil koleksiyon, 'ana kapsayıcı' olarak adlandıralım, çeşitli 'alt kapsayıcı'lara veya 'çanta'lara işaretçileri tutacaktır. Her 'çanta' kendi başına dinamik olarak ayrılmış bir tamsayı dizisidir. İşaretçiyi boyutu ve kapasitesiyle birlikte paketlemek için `struct` kullanamayacağınızdan, her alt kapsayıcı için `mevcut_boyut` ve `mevcut_kapasite`yi izlemek üzere ayrı, paralel dinamik diziler tutmanız gerekmektedir. Bu, ana kapsayıcı için bir `int**` ile birlikte, meta verileri için karşılık gelen iki `int*` dizisini etkili bir şekilde yöneteceğiniz anlamına gelir.

Özellikle, programınızın aşağıdakileri göstermesi gerekmektedir: İlk olarak, alt kapsayıcılara işaretçileri tutmak için ana kapsayıcıyı başlangıç kapasitesiyle başlatın, `int**` ve iki paralel meta veri `int*` dizisi için bellek ayırın. İkinci olarak, ana kapsayıcıya yeni, boş alt kapsayıcılar eklemek için bir mantık uygulayın. Bu işlem, ana kapsayıcı kapasitesine ulaşırsa `int**` (ve meta veri dizilerini) `realloc` kullanarak yeniden boyutlandırmayı ele almalıdır. Her yeni alt kapsayıcı, kendi başlangıç kapasitesine sahip boş bir `int*` dizisi olarak başlatılmalıdır. Üçüncü olarak, belirtilen bir alt kapsayıcıya bir tamsayı değeri eklemek için bir mantık uygulayın. Bu işlem de, hedef `int*` dizisi kapasitesine ulaşırsa `realloc` işlemi gerçekleştirmelidir. Son olarak, tüm alt kapsayıcıların içeriğini, mevcut boyutlarını ve kapasitelerini göstererek yazdırın ve ardından herhangi bir bellek sızıntısını önlemek için dinamik olarak ayrılmış tüm belleği titizlikle boşaltın.