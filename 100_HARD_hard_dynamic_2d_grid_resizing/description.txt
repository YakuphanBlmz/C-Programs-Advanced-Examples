EN

This problem challenges you to implement a dynamic 2D integer grid in C, managing its dimensions entirely through raw pointers and dynamic memory allocation. You will create a flexible grid structure where both the number of rows and columns can be altered at runtime. The core of this challenge lies in correctly resizing the grid using `realloc`, handling memory reallocations for both the array of row pointers and each individual row's integer array.

Your primary task is to implement a function, `resize_grid`, that dynamically adjusts the dimensions of the grid. This function will accept a pointer to the grid (a `int***`), pointers to the current row and column counts (two `int*`), and the new desired dimensions (`new_rows`, `new_cols`), along with a `default_value` for newly added cells. When `new_rows` is greater than the current number of rows, new rows must be allocated. Similarly, if `new_cols` exceeds the current column count, existing rows must be reallocated to accommodate more columns, and new cells initialized with the `default_value`. If `new_rows` or `new_cols` are smaller than the current dimensions, you must correctly deallocate memory for any truncated rows or columns to prevent memory leaks.

Beyond `resize_grid`, you will also need to implement helper functions for initializing an empty grid, safely getting and setting values at specific coordinates (including bounds checking), printing the grid's contents, and most importantly, ensuring all dynamically allocated memory is properly freed upon program termination. This problem demands a deep understanding of pointer arithmetic, multiple levels of indirection, and careful memory management to avoid common pitfalls like memory leaks, double-frees, or dangling pointers. The success of your solution hinges on precise control over `malloc`, `realloc`, and `free` operations across a multi-level dynamic structure.

TR

Bu problem, C dilinde dinamik bir 2D tam sayı ızgarasını, boyutlarını tamamen ham işaretçiler ve dinamik bellek tahsisi yoluyla yöneterek uygulamanızı hedeflemektedir. Hem satır hem de sütun sayısının çalışma zamanında değiştirilebildiği esnek bir ızgara yapısı oluşturacaksınız. Bu zorluğun merkezinde, ızgarayı `realloc` kullanarak doğru bir şekilde yeniden boyutlandırmak, hem satır işaretçileri dizisi hem de her bir satırın tam sayı dizisi için bellek yeniden tahsislerini yönetmek yatmaktadır.

Ana göreviniz, ızgaranın boyutlarını dinamik olarak ayarlayan bir `resize_grid` fonksiyonunu uygulamaktır. Bu fonksiyon, ızgaraya bir işaretçi (bir `int***`), mevcut satır ve sütun sayılarına işaretçiler (iki `int*`), istenen yeni boyutlar (`new_rows`, `new_cols`) ve yeni eklenen hücreler için bir `default_value` parametresi alacaktır. `new_rows` mevcut satır sayısından büyükse, yeni satırlar tahsis edilmelidir. Benzer şekilde, `new_cols` mevcut sütun sayısını aşarsa, mevcut satırlar daha fazla sütunu barındırmak için yeniden tahsis edilmeli ve yeni hücreler `default_value` ile başlatılmalıdır. Eğer `new_rows` veya `new_cols` mevcut boyutlardan küçükse, bellek sızıntılarını önlemek için kesilen satırlar veya sütunlar için belleği doğru bir şekilde serbest bırakmalısınız.

`resize_grid`'in yanı sıra, boş bir ızgarayı başlatmak, belirli koordinatlardaki değerleri güvenli bir şekilde almak ve ayarlamak (sınır kontrolü dahil), ızgaranın içeriğini yazdırmak ve en önemlisi, program sonlandığında tüm dinamik olarak tahsis edilen belleğin düzgün bir şekilde serbest bırakıldığından emin olmak için yardımcı fonksiyonlar uygulamanız gerekecektir. Bu problem, işaretçi aritmetiği, çoklu dolaylılık seviyeleri ve bellek sızıntıları, çift serbest bırakma veya sarkan işaretçiler gibi yaygın hatalardan kaçınmak için dikkatli bellek yönetimi konularında derin bir anlayış gerektirir. Çözümünüzün başarısı, çok seviyeli dinamik bir yapıdaki `malloc`, `realloc` ve `free` işlemlerinin kesin kontrolüne bağlıdır.