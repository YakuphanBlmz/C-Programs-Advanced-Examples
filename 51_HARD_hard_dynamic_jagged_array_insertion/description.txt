EN

This problem challenges your understanding of advanced pointer manipulation and dynamic memory management in C, specifically without the aid of `struct` or `typedef`. You are tasked with managing a "jagged array" – an array where each "row" is itself a dynamically allocated array of integers, and these rows can have different lengths. To keep track of these varying lengths, you will maintain a separate, parallel dynamic array storing the length of each corresponding row.

Your primary goal is to implement a robust C function that dynamically inserts a new row at the beginning of this jagged array. This operation is complex: it requires reallocating the main array of row pointers (`int**`) to accommodate the new row, and crucially, also reallocating the parallel array of row lengths (`int*`). Both reallocations will involve updating the base pointers of these dynamic arrays, meaning your function will need to accept pointers-to-pointers (`int***` for the jagged array and `int**` for the row lengths array) for these modifications.

After resizing, all existing rows and their corresponding lengths must be shifted one position to the right to make space for the new row at index 0. Finally, memory for the new row's data must be allocated using `malloc`, the data copied, and the new row's pointer and length placed at the beginning of their respective arrays. The solution must correctly handle all memory allocations, reallocations, and proper memory deallocation at the end to prevent leaks. Your implementation must strictly avoid using `struct`, `typedef`, or `file I/O`.

TR

Bu problem, `struct` veya `typedef` gibi yardımcı yapılar kullanmadan, C dilinde gelişmiş işaretçi manipülasyonu ve dinamik bellek yönetimini sınamaktadır. Göreviniz, "pürüzlü bir dizi" (jagged array) yönetmektir – bu, her bir "satırın" kendisi dinamik olarak tahsis edilmiş bir tam sayı dizisi olduğu ve bu satırların farklı uzunluklara sahip olabileceği bir dizidir. Bu değişen uzunlukları takip etmek için, her bir satırın karşılık gelen uzunluğunu depolayan ayrı, paralel bir dinamik dizi tutacaksınız.

Temel hedefiniz, bu pürüzlü dizinin başına dinamik olarak yeni bir satır ekleyen sağlam bir C fonksiyonu uygulamaktır. Bu işlem karmaşıktır: yeni satıra yer açmak için ana satır işaretçileri dizisini (`int**`) yeniden tahsis etmeyi ve ayrıca paralel satır uzunlukları dizisini (`int*`) yeniden tahsis etmeyi gerektirir. Her iki yeniden tahsis işlemi de bu dinamik dizilerin temel işaretçilerini güncellemeyi içereceğinden, fonksiyonunuz bu değişiklikler için işaretçinin işaretçilerini (pürüzlü dizi için `int***` ve satır uzunlukları dizisi için `int**`) kabul etmek zorunda kalacaktır.

Yeniden boyutlandırmadan sonra, mevcut tüm satırlar ve bunlara karşılık gelen uzunluklar, 0. dizinde yeni satıra yer açmak için bir konum sağa kaydırılmalıdır. Son olarak, yeni satırın verileri için `malloc` kullanılarak bellek ayrılmalı, veriler kopyalanmalı ve yeni satırın işaretçisi ile uzunluğu kendi dizilerinin başına yerleştirilmelidir. Çözüm, tüm bellek tahsislerini, yeniden tahsislerini ve bellek sızıntılarını önlemek için sonunda doğru bellek serbest bırakmayı doğru bir şekilde ele almalıdır. Uygulamanız `struct`, `typedef` veya `dosya işlemleri` kullanmaktan kesinlikle kaçınmalıdır.