EN

In C programming, managing memory dynamically with pointers is a fundamental skill, but it quickly becomes challenging when dealing with complex data structures without the aid of higher-level constructs. This problem requires you to implement a custom dynamic collection that stores individual dynamically allocated integer values. Instead of storing actual integers directly within the collection, you will store *pointers* to integers, each of which resides in its own dynamically allocated memory block. This approach emphasizes deep understanding of `malloc`, `realloc`, and `free` in a multi-layered memory management scenario.

Your task is to manage this collection, which will essentially be a dynamic array of `int*` (a `int**`). You must implement functionalities to add new integer values, remove existing ones, retrieve a value at a specific index, and display all current values. When adding a new integer, you will first `malloc` space for a single `int`, store the value there, and then add the pointer to this newly allocated `int` into your main `int**` collection. The `int**` collection itself must be dynamically resizable using `realloc` as elements are added or removed. This requires careful handling of pointer arithmetic and memory reallocation logic, especially when `realloc` might move the entire collection to a new memory location.

Particular attention must be paid to memory safety: every `malloc` must eventually be matched by a `free`. When an element is removed, not only must its pointer be removed from the `collection`, but the individual `int` it pointed to must also be `free`d. Similarly, during cleanup, all individual `int`s must be `free`d before the main `collection` (the `int**`) is `free`d. Remember, you are strictly forbidden from using `struct`, `typedef`, or any file I/O operations. This forces a raw pointer approach, pushing your understanding of C's memory model to its limits.

TR

C programlamada, işaretçilerle dinamik bellek yönetimi temel bir beceridir, ancak yüksek seviyeli yapılar kullanılmadan karmaşık veri yapılarıyla uğraşırken hızla zorlaşır. Bu problem, bireysel olarak dinamik olarak tahsis edilmiş tamsayı değerlerini depolayan özel bir dinamik koleksiyon uygulamanızı gerektirir. Koleksiyonun içine doğrudan gerçek tamsayılar depolamak yerine, her biri kendi dinamik olarak tahsis edilmiş bellek bloğunda bulunan tamsayılara ait *işaretçileri* depolayacaksınız. Bu yaklaşım, çok katmanlı bir bellek yönetimi senaryosunda `malloc`, `realloc` ve `free` konularında derin bir anlayışı vurgulamaktadır.

Göreviniz, esasen `int*`'lardan oluşan dinamik bir dizi (`int**`) olacak bu koleksiyonu yönetmektir. Yeni tamsayı değerleri eklemek, mevcut olanları kaldırmak, belirli bir dizindeki değeri almak ve tüm mevcut değerleri görüntülemek için işlevsellikler uygulamanız gerekmektedir. Yeni bir tamsayı eklerken, önce tek bir `int` için yer `malloc` ile ayıracak, değeri oraya depolayacak ve ardından bu yeni tahsis edilen `int`'in işaretçisini ana `int**` koleksiyonunuza ekleyeceksiniz. `int**` koleksiyonunun kendisi, öğeler eklendikçe veya kaldırıldıkça `realloc` kullanılarak dinamik olarak yeniden boyutlandırılabilmelidir. Bu, özellikle `realloc` tüm koleksiyonu yeni bir bellek konumuna taşıyabilecekken, işaretçi aritmetiği ve bellek yeniden tahsis mantığının dikkatli bir şekilde ele alınmasını gerektirir.

Bellek güvenliğine özel dikkat gösterilmelidir: her `malloc` nihayetinde bir `free` ile eşleşmelidir. Bir öğe kaldırıldığında, yalnızca işaretçisi `collection`'dan kaldırılmakla kalmamalı, aynı zamanda işaret ettiği bireysel `int` de `free` edilmelidir. Benzer şekilde, temizleme sırasında, ana `collection` (`int**`) `free` edilmeden önce tüm bireysel `int`'ler `free` edilmelidir. `struct`, `typedef` veya herhangi bir dosya I/O işlemi kullanmanızın kesinlikle yasak olduğunu unutmayın. Bu, C'nin bellek modeline dair anlayışınızı sınırlara zorlayan, ham bir işaretçi yaklaşımını zorunlu kılar.