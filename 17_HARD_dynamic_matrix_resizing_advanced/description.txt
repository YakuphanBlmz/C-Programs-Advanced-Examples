EN

In advanced C programming, mastering dynamic memory allocation for multi-dimensional data structures without the aid of user-defined types like `struct` presents a significant challenge. This problem requires you to implement a robust and flexible dynamic 2D integer matrix (a matrix of integers) where both its rows and columns can be resized at runtime. This task is crucial in areas like scientific computing or image processing, where data dimensions frequently change.

Your primary goal is to manage a `int**` type representing the matrix. You must implement several functions:
1.  `create_matrix(int rows, int cols)`: Allocates and initializes a new `rows` x `cols` matrix. All elements should be set to 0. It should return a `int**` pointer.
2.  `resize_matrix(int*** matrix_ptr, int* current_rows_ptr, int* current_cols_ptr, int new_rows, int new_cols)`: This is the core of the problem. It must efficiently resize the matrix pointed to by `matrix_ptr` to `new_rows` x `new_cols`. This function will involve careful use of `realloc` for both the array of row pointers and each individual row's data. If `new_rows` or `new_cols` are 0, all memory associated with the matrix must be freed, and `matrix_ptr` set to `NULL` along with dimension pointers set to 0. When expanding, new cells (both new rows and new columns in existing rows) must be initialized to 0. When shrinking, memory for removed rows and columns must be properly freed to prevent leaks. Note that `matrix_ptr` is `int***` because the function needs to modify where the `int**` matrix pointer itself points (e.g., if `realloc` moves the block, or if the matrix becomes `NULL`). Similarly, `current_rows_ptr` and `current_cols_ptr` are `int*` to allow modification of the dimensions in the caller's scope.
3.  `print_matrix(int** matrix, int rows, int cols)`: Prints the current state of the matrix to standard output.
4.  `free_matrix(int*** matrix_ptr, int* rows_ptr)`: Deallocates all memory associated with the matrix, sets `*matrix_ptr` to `NULL`, and `*rows_ptr` to 0.

This problem explicitly forbids the use of `struct`, `typedef`, and file I/O operations. Your solution must rely solely on raw pointers (`int*`, `int**`, `int***`), `malloc`, `realloc`, and `free` from `stdlib.h`. Pay extreme attention to pointer arithmetic, null checks, and ensuring no memory leaks or double frees occur. The `resize_matrix` function, in particular, will test your understanding of complex dynamic memory management and pointer-to-pointer concepts.

TR

İleri C programlamada, `struct` gibi kullanıcı tanımlı tiplerin yardımı olmadan çok boyutlu veri yapıları için dinamik bellek tahsisinde ustalaşmak önemli bir zorluktur. Bu problem, hem satırları hem de sütunları çalışma zamanında yeniden boyutlandırılabilen, sağlam ve esnek bir dinamik 2D tamsayı matrisi (tamsayılardan oluşan bir matris) uygulamanızı gerektirir. Bu görev, veri boyutlarının sıkça değiştiği bilimsel hesaplama veya görüntü işleme gibi alanlarda çok önemlidir.

Temel hedefiniz, matrisi temsil eden bir `int**` tipini yönetmektir. Birkaç fonksiyon uygulamanız gerekmektedir:
1.  `create_matrix(int rows, int cols)`: Yeni bir `rows` x `cols` matris tahsis eder ve başlatır. Tüm elemanlar 0 olarak ayarlanmalıdır. Bir `int**` işaretçisi döndürmelidir.
2.  `resize_matrix(int*** matrix_ptr, int* current_rows_ptr, int* current_cols_ptr, int new_rows, int new_cols)`: Bu, problemin temelini oluşturur. `matrix_ptr` tarafından işaret edilen matrisi `new_rows` x `new_cols` boyutlarına verimli bir şekilde yeniden boyutlandırmalıdır. Bu fonksiyon, hem satır işaretçileri dizisi hem de her bir satırın verisi için `realloc`'un dikkatli kullanımını içerecektir. Eğer `new_rows` veya `new_cols` 0 ise, matrisle ilişkili tüm bellek serbest bırakılmalı ve `matrix_ptr` `NULL`, boyut işaretçileri ise 0 olarak ayarlanmalıdır. Genişletme yapıldığında, yeni hücreler (hem yeni satırlar hem de mevcut satırlardaki yeni sütunlar) 0 olarak başlatılmalıdır. Küçültme yapıldığında, kaldırılan satırlar ve sütunlar için bellek sızıntılarını önlemek amacıyla doğru bir şekilde serbest bırakılmalıdır. `matrix_ptr`'ın `int***` olduğuna dikkat edin, çünkü fonksiyonun `int**` matris işaretçisinin kendisinin işaret ettiği yeri değiştirmesi gerekebilir (örneğin, `realloc` bloğu taşırsa veya matris `NULL` olursa). Benzer şekilde, `current_rows_ptr` ve `current_cols_ptr` çağrı yapanın kapsamındaki boyutları değiştirmeye izin vermek için `int*` tipindedir.
3.  `print_matrix(int** matrix, int rows, int cols)`: Matrisin mevcut durumunu standart çıktıya yazdırır.
4.  `free_matrix(int*** matrix_ptr, int* rows_ptr)`: Matrisle ilişkili tüm belleği serbest bırakır, `*matrix_ptr`'ı `NULL`'a ve `*rows_ptr`'ı 0'a ayarlar.

Bu problem, `struct`, `typedef` ve dosya I/O işlemlerinin kullanımını açıkça yasaklar. Çözümünüz yalnızca ham işaretçilere (`int*`, `int**`, `int***`), `stdlib.h`'den `malloc`, `realloc` ve `free`'ye dayanmalıdır. İşaretçi aritmetiğine, null denetimlerine ve bellek sızıntıları veya çift serbest bırakmaların olmadığından emin olmaya aşırı dikkat edin. Özellikle `resize_matrix` fonksiyonu, karmaşık dinamik bellek yönetimi ve işaretçinin işaretçisi kavramlarına olan anlayışınızı test edecektir.