EN

This problem challenges you to implement a dynamic data structure capable of managing multiple independent sequences of integers, all while adhering to strict memory management principles without the aid of higher-level abstractions like `struct` or `typedef`. Your task is to construct a system that can dynamically grow and shrink, allocating memory as needed for both the collection of sequences itself and for the individual sequences within it. This requires meticulous handling of raw pointers, `malloc`, `realloc`, and `free` operations, making it a truly "HARD" test of your C memory management skills.

Specifically, you will manage a "manager" layer that holds pointers to various integer sequences. This manager layer will be represented by an `int**` for the sequence data, and parallel `int*` arrays to track the current size and allocated capacity for each individual sequence. As sequences are added or modified, these parallel arrays, along with the main `int**` array, must be dynamically resized using `realloc`. Similarly, each individual integer sequence will be a `int*` that grows dynamically as elements are added, also requiring `realloc` for its own underlying memory block.

The core of the problem involves simulating a series of operations: initializing the manager, adding several empty sequences, populating these sequences with arbitrary integer values, and crucially, performing a complex "merge" operation. This merge operation will combine two existing sequences into one, replacing one of the original sequences with the merged result and completely removing the other. This demands careful memory deallocation of the removed sequence, reallocation of the target sequence to accommodate new data, and then shifting subsequent sequences and their metadata (sizes, capacities) within the manager's parallel arrays to fill the gap. Finally, all dynamically allocated memory must be properly freed to prevent leaks. This intricate dance of pointer manipulation and dynamic memory resizing without the convenience of structs or helper functions is what defines the "HARD" nature of this challenge.

TR

Bu problem, C programlama dilinde `struct` veya `typedef` gibi üst düzey soyutlamalardan yararlanmadan, tamamen ham işaretçiler ve dinamik bellek yönetimi prensipleriyle birden çok bağımsız tam sayı dizisini (sekansını) yönetebilen dinamik bir veri yapısı uygulamanızı gerektiriyor. Göreviniz, hem sekans koleksiyonunun kendisi hem de içindeki bireysel sekanslar için gerektiğinde bellek tahsis eden, büyüyüp küçülebilen bir sistem inşa etmektir. Bu, `malloc`, `realloc` ve `free` operasyonları ile ham işaretçilerin titizlikle ele alınmasını gerektirir ve bu da onu C bellek yönetimi becerilerinizin gerçekten "ZOR" bir testi haline getirir.

Özellikle, çeşitli tam sayı sekanslarına işaretçileri tutan bir "yönetici" katmanı uygulayacaksınız. Bu yönetici katmanı, sekans verileri için bir `int**` ve her bir sekansın mevcut boyutunu ve ayrılan kapasitesini izlemek için paralel `int*` dizileri ile temsil edilecektir. Sekanslar eklendikçe veya değiştirildikçe, bu paralel diziler ve ana `int**` dizisi, `realloc` kullanılarak dinamik olarak yeniden boyutlandırılmalıdır. Benzer şekilde, her bir bireysel tam sayı sekansı, öğeler eklendikçe dinamik olarak büyüyen bir `int*` olacak ve kendi temel bellek bloğu için de `realloc` gerektirecektir.

Problemin özü, bir dizi işlemi simüle etmektir: yöneticiyi başlatmak, birkaç boş sekans eklemek, bu sekansları rastgele tam sayı değerleriyle doldurmak ve en önemlisi, karmaşık bir "birleştirme" (merge) işlemi gerçekleştirmek. Bu birleştirme işlemi, mevcut iki sekansı birleştirerek tek bir sekans oluşturacak, orijinal sekanslardan birini birleştirilmiş sonuçla değiştirecek ve diğerini tamamen kaldıracaktır. Bu, kaldırılan sekansın belleğinin dikkatli bir şekilde serbest bırakılmasını, hedef sekansın yeni verileri barındırmak için yeniden tahsis edilmesini ve ardından yönetici dizilerindeki (boyutlar, kapasiteler) sonraki sekansların ve meta verilerinin boşluğu doldurmak için kaydırılmasını gerektirir. Son olarak, bellek sızıntılarını önlemek için tüm dinamik olarak ayrılmış belleğin düzgün bir şekilde serbest bırakılması zorunludur. Yapıların (struct) veya yardımcı fonksiyonların rahatlığı olmadan işaretçi manipülasyonunun ve dinamik bellek yeniden boyutlandırmasının bu karmaşık dansı, bu zorluğun "HARD" doğasını tanımlamaktadır.