EN

This challenging problem requires you to meticulously manage a complex data structure purely through pointers and dynamic memory allocation, without the aid of `struct`s or `typedef`s. You are tasked with creating and manipulating a dynamic collection of integer arrays. Each of these inner integer arrays, conceptually a 'row', will itself be dynamically allocated. The overarching collection will be managed using a `pointer to pointer to int` (`int**`), serving as the primary container for references to these 'rows'. Alongside this, you must maintain a parallel dynamic array (`int*`) to store the respective sizes of each row, ensuring data integrity and consistency throughout all operations.

Your program must implement a series of operations to demonstrate robust dynamic memory handling. Initially, you will dynamically allocate an `int**` to hold references to `N` rows. For each of these `N` rows, you will then dynamically allocate an `int*` of varying sizes (`S_i`) and populate them with some pattern (e.g., `(current_row_index + 1) * 10 + element_index`). Following initialization, you must implement the ability to *add* a new row: this involves `reallocating` the main `int**` container, `reallocating` the `rowSizes` array, and `malloc`ing the new row's data. A crucial part of this problem is the *sorting* mechanism: you must sort the entire collection of rows. The primary sorting key is the sum of elements within each row in ascending order. If two rows have identical sums, their relative order should be determined by their first element, also in ascending order. This sorting operation must be performed by swapping the `int*` pointers within your `int**` container, and simultaneously updating the corresponding `rowSizes` entries.

Furthermore, you must implement a robust *row removal* operation. Given an index `K`, your program needs to `free` the memory associated with that specific row, then `reallocate` both the main `int**` container and the `rowSizes` array to reflect the removal, carefully shifting subsequent row pointers and sizes. Finally, and critically, your solution must demonstrate impeccable memory hygiene. Before program termination, all dynamically allocated memory—including each individual row, the `int**` container itself, and the `rowSizes` array—must be properly `free`d to prevent any memory leaks. This problem heavily tests your understanding of `malloc`, `realloc`, `free`, and the intricate dance of `pointer to pointer` manipulation in C.

TR

Bu zorlu problem, `struct` veya `typedef` gibi yardımcı araçlar kullanmadan, tamamen işaretçiler ve dinamik bellek tahsisi aracılığıyla karmaşık bir veri yapısını titizlikle yönetmenizi gerektirir. Dinamik olarak tahsis edilmiş tamsayı dizilerinden (satırlar) oluşan dinamik bir koleksiyon oluşturma ve bu koleksiyonu manipüle etme göreviniz var. Bu iç tamsayı dizilerinin her biri, kavramsal olarak bir 'satır' olarak ele alınacak ve kendi içinde dinamik olarak tahsis edilecektir. Ana koleksiyon, bu 'satırlara' referansları tutan bir `int**` (tamsayı işaretçisinin işaretçisi) kullanılarak yönetilecektir. Buna ek olarak, her satırın ilgili boyutlarını depolamak için ayrı bir dinamik dizi (`int*`) sürdürmeli, tüm işlemler boyunca veri bütünlüğünü ve tutarlılığını sağlamalısınız.

Programınız, güçlü dinamik bellek yönetimini sergilemek için bir dizi işlem uygulamalıdır. Başlangıçta, `N` adet satıra referansları tutacak bir `int**` dinamik olarak tahsis edeceksiniz. Bu `N` satırın her biri için, değişen boyutlarda (`S_i`) bir `int*` dinamik olarak tahsis edip bunları belirli bir desenle (örneğin, `(mevcut_satır_indeksi + 1) * 10 + eleman_indeksi`) doldurmanız gerekecektir. Başlatma işleminin ardından, yeni bir satır *ekleme* yeteneğini uygulamalısınız: bu, ana `int**` konteynerini `realloc` etmek, `rowSizes` dizisini `realloc` etmek ve yeni satırın verisini `malloc` etmek anlamına gelir. Bu problemin kritik bir kısmı *sıralama* mekanizmasıdır: tüm satır koleksiyonunu sıralamanız gerekmektedir. Birincil sıralama anahtarı, her satırdaki elemanların toplamıdır (artan sırada). Eğer iki satırın toplamı aynıysa, göreceli sıraları ilk elemanlarına göre (yine artan sırada) belirlenmelidir. Bu sıralama işlemi, `int**` konteynerinizdeki `int*` işaretçilerini takas ederek ve eş zamanlı olarak ilgili `rowSizes` girişlerini güncelleyerek yapılmalıdır.

Ayıca, güçlü bir *satır kaldırma* işlemi uygulamalısınız. Belirli bir `K` indeksindeki satır verildiğinde, programınızın o belirli satırla ilişkili belleği `free` etmesi, ardından ana `int**` konteynerini ve `rowSizes` dizisini kaldırmayı yansıtacak şekilde `realloc` etmesi ve sonraki satır işaretçilerini ve boyutlarını dikkatlice kaydırması gerekmektedir. Son olarak ve en önemlisi, çözümünüz kusursuz bellek hijyeni sergilemelidir. Program sonlandırmadan önce, her bir bireysel satır, `int**` konteynerinin kendisi ve `rowSizes` dizisi dahil olmak üzere tüm dinamik olarak tahsis edilmiş bellek, bellek sızıntılarını önlemek için uygun şekilde `free` edilmelidir. Bu problem, C dilinde `malloc`, `realloc`, `free` ve `pointer to pointer` manipülasyonunun karmaşık dansı hakkındaki anlayışınızı yoğun bir şekilde test edecektir.