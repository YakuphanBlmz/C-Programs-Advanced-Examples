EN

This problem challenges your mastery of pointers and dynamic memory allocation in C by requiring you to implement a complex, multi-layered data structure. You are tasked with creating a system to manage a 'Dynamic Grid of Dynamic Arrays'. This isn't just a simple 2D array of integers; instead, each cell within the grid will itself hold a pointer to a *separate, dynamically allocated 1D array of integers*. The sizes of these inner 1D arrays can vary independently, making memory management particularly intricate. To further complicate matters and avoid forbidden types, the size of each 1D array should be stored as the *first element* (at index 0) of its own dynamically allocated memory block, with the actual data starting from index 1. This means an array of `N` elements will require `N+1` integers of storage. Your main grid structure will thus be an `int***`. 

Your primary goal is to manage this `int***` structure, which represents a grid where `grid[row][col]` provides access to a pointer to a dynamically allocated 1D array. You must be able to initialize this grid with specified dimensions, allocate the inner 1D arrays for each cell, and populate them with data. A core functionality involves a `merge` operation: given two grid coordinates `(r1, c1)` and `(r2, c2)`, you must take the entire content (the 1D array, including its internal size marker) from `(r2, c2)`, append it to the 1D array at `(r1, c1)`, and then properly deallocate the original 1D array at `(r2, c2)`, setting its pointer to `NULL`. This `merge` operation will necessitate the careful use of `realloc` for the destination array to accommodate the new appended data.

Furthermore, the problem demands that the main 2D grid itself must be dynamically resizable. You should be able to extend or shrink the number of rows and columns. When shrinking, ensure all inner 1D arrays belonging to the removed rows/columns are correctly freed. When expanding, new cells should be initialized appropriately (e.g., with `NULL` pointers for their inner arrays). Finally, a robust memory cleanup routine is essential to free all allocated memory at the end of the program's execution, preventing any memory leaks. This includes deallocating all inner 1D arrays, then each row array of pointers, and finally the main array of row pointers. Neglecting any of these steps will result in memory errors or leaks.

TR

Bu problem, C dilinde işaretçiler ve dinamik bellek yönetimi konusundaki ustalığınızı, karmaşık, çok katmanlı bir veri yapısı uygulamanızı gerektirerek zorluyor. Sizden, 'Dinamik Dizilerin Dinamik Izgarası'nı yönetmek için bir sistem oluşturmanız istenmektedir. Bu, yalnızca basit bir 2D tam sayı dizisi değildir; bunun yerine, ızgaradaki her hücre, *ayrı, dinamik olarak ayrılmış bir 1D tam sayı dizisine* bir işaretçi tutacaktır. Bu iç 1D dizilerinin boyutları bağımsız olarak değişebilir, bu da bellek yönetimini özellikle karmaşık hale getirir. Yasaklı türlerden kaçınmak için, her 1D dizinin boyutu, dinamik olarak ayrılmış kendi bellek bloğunun *ilk öğesi* (indeks 0'da) olarak saklanmalı ve gerçek veriler indeks 1'den başlamalıdır. Bu, `N` elemanlı bir dizinin `N+1` tam sayı depolama alanı gerektireceği anlamına gelir. Ana ızgara yapınız bu nedenle `int***` olacaktır.

Temel hedefiniz, `grid[row][col]`'un dinamik olarak ayrılmış bir 1D diziye bir işaretçiye erişim sağladığı bir ızgarayı temsil eden bu `int***` yapısını yönetmektir. Bu ızgarayı belirtilen boyutlarla başlatmalı, her hücre için iç 1D dizilerini ayırmalı ve bunları veriyle doldurmalısınız. Temel bir işlevsellik, bir 'birleştirme' (merge) işlemini içerir: verilen iki ızgara koordinatı `(r1, c1)` ve `(r2, c2)` için, `(r2, c2)` konumundaki tüm içeriği (1D diziyi, kendi iç boyut belirteci dahil) almalı, bunu `(r1, c1)` konumundaki 1D dizisine eklemeli ve ardından `(r2, c2)` konumundaki orijinal 1D dizisini uygun şekilde serbest bırakmalı, işaretçisini `NULL` olarak ayarlamalısınız. Bu 'birleştirme' işlemi, yeni eklenen verileri barındırmak için hedef dizi için `realloc` kullanımını dikkatli bir şekilde gerektirecektir.

Ayrıca, problem ana 2D ızgaranın kendisinin dinamik olarak yeniden boyutlandırılabilir olmasını talep etmektedir. Satır ve sütun sayısını genişletebilmeli veya daraltabilmelisiniz. Daraltırken, kaldırılan satır/sütunlara ait tüm iç 1D dizilerinin doğru şekilde serbest bırakıldığından emin olun. Genişletirken, yeni hücreler uygun şekilde başlatılmalıdır (örneğin, iç dizileri için `NULL` işaretçileriyle). Son olarak, programın yürütülmesi sonunda ayrılmış tüm belleği serbest bırakarak bellek sızıntılarını önlemek için sağlam bir bellek temizleme rutini gereklidir. Bu, tüm iç 1D dizilerini, ardından her bir satır işaretçi dizisini ve son olarak ana satır işaretçileri dizisini serbest bırakmayı içerir. Bu adımlardan herhangi birinin ihmal edilmesi bellek hatalarına veya sızıntılarına yol açacaktır.