EN

In C programming, managing dynamic two-dimensional arrays, often referred to as matrices or grids, is a cornerstone of advanced memory management. This challenge elevates that concept by requiring not only their creation and destruction but also their dynamic resizing, all while adhering to strict memory management principles.

Your task is to implement a system that can manage a dynamic 2D array of integers. Initially, the array will be allocated with `M` rows and `N` columns. However, the core of this problem lies in its ability to be resized to new dimensions, `M'` rows and `N'` columns, at any point. When resizing, existing data within the overlapping regions of the old and new dimensions must be preserved. If a dimension grows, the new cells should remain uninitialized. If a dimension shrinks, the excess cells (and their associated memory) must be properly deallocated. This requires careful use of `malloc`, `realloc`, and `free` at multiple levels: first for the array of row pointers, and then for each individual row's data.

This problem is particularly challenging because it explicitly forbids the use of `struct`, `typedef`, or `file I/O`. This means you cannot encapsulate the matrix pointer and its dimensions (`rows`, `cols`) into a single structure. Instead, you must manage these pieces of information separately, likely passing pointers to them (e.g., `int*** matrixPtr`, `int* rowsPtr`, `int* colsPtr`) to any helper functions responsible for allocation, resizing, or deallocation. Meticulous attention to pointer arithmetic, `NULL` checks after every allocation attempt, and the correct order of freeing memory are paramount to prevent memory leaks, double-frees, or dangling pointers. The solution must demonstrate a robust and efficient approach to handling these complex dynamic memory operations.

TR

C programlamada, genellikle matrisler veya ızgaralar olarak adlandırılan dinamik iki boyutlu dizilerin yönetimi, ileri düzey bellek yönetiminin temelini oluşturur. Bu meydan okuma, sadece oluşturma ve yok etme değil, aynı zamanda boyutlarını dinamik olarak yeniden boyutlandırma yeteneğini de gerektirerek bu kavramı bir üst seviyeye taşımakta ve tüm bunları katı bellek yönetimi ilkelerine bağlı kalarak yapmayı istemektedir.

Göreviniz, dinamik bir 2D tam sayı dizisini yönetebilen bir sistem uygulamaktır. Başlangıçta, dizi `M` satır ve `N` sütun ile tahsis edilecektir. Ancak, bu problemin özü, herhangi bir zamanda `M'` satır ve `N'` sütunluk yeni boyutlara yeniden boyutlandırılabilme yeteneğinde yatmaktadır. Yeniden boyutlandırma sırasında, eski ve yeni boyutların çakışan bölgelerindeki mevcut veriler korunmalıdır. Bir boyut büyürse, yeni hücreler başlatılmamış olarak kalmalıdır. Bir boyut küçülürse, fazla hücreler (ve ilişkili bellekleri) uygun şekilde serbest bırakılmalıdır. Bu, `malloc`, `realloc` ve `free` fonksiyonlarının birden çok seviyede dikkatli kullanımını gerektirir: önce satır işaretçileri dizisi için ve sonra her bir satırın verisi için.

Bu problem, `struct`, `typedef` veya `dosya I/O` kullanımını açıkça yasakladığı için özellikle zordur. Bu, matris işaretçisini ve boyutlarını (`satır`, `sütun`) tek bir yapıda birleştiremeyeceğiniz anlamına gelir. Bunun yerine, bu bilgi parçalarını ayrı ayrı yönetmeniz gerekecektir; büyük olasılıkla tahsis, yeniden boyutlandırma veya serbest bırakmadan sorumlu yardımcı fonksiyonlara işaretçiler aracılığıyla (örneğin, `int*** matrixPtr`, `int* rowsPtr`, `int* colsPtr`) iletmeniz gerekecektir. İşaretçi aritmetiğine titiz dikkat, her bellek tahsis denemesinden sonra `NULL` kontrolleri ve bellek sızıntılarını, çifte serbest bırakmaları veya sarkık işaretçileri önlemek için doğru bellek serbest bırakma sırası son derece önemlidir. Çözüm, bu karmaşık dinamik bellek işlemlerini ele almak için sağlam ve verimli bir yaklaşım sergilemelidir.