EN

In advanced C programming, mastering dynamic memory management for multi-dimensional data structures is crucial, especially when fixed-size arrays are insufficient. This challenge focuses on creating and manipulating a three-dimensional (3D) array of integers, often conceptualized as a 'cube' of data, using only pointers and dynamic allocation.

You are tasked with dynamically allocating a 3D integer array of initial dimensions `D1 x D2 x D3`. This involves a 'pointer to pointer to pointer' structure (`int***`), where the outermost pointer points to an array of pointers to 2D planes, each of which points to an array of pointers to 1D rows, which finally point to arrays of integers. After allocation, the cube must be initialized with a specific pattern to demonstrate successful data storage and access. You will need nested loops to allocate memory at each level and to populate the array with values, carefully casting the results of `malloc` and `realloc`.

The core difficulty arises from a subsequent resizing operation. You must extend one of the dimensions (e.g., `D1`) to a new, larger size `D1_new`. This requires careful use of `realloc` for the outermost dimension. Importantly, `realloc` might move the entire block to a new memory location if it cannot extend the block in place, so you must update your base pointer (`int***`). For the newly added 'planes' (or rows/columns depending on which dimension you extend), you must allocate the corresponding internal 2D and 1D arrays and initialize their elements. This operation tests your deep understanding of how `realloc` interacts with nested dynamic allocations and requires precise memory management to avoid leaks or invalid accesses during the transition, including robust error handling for `malloc` and `realloc` failures at each level.

Finally, after all operations, you must correctly deallocate all memory segments allocated for the 3D array. This involves freeing the innermost blocks first, then the intermediate blocks, and finally the outermost block, ensuring no memory leaks occur. The solution must strictly avoid using `struct`, `typedef`, or any file I/O operations, relying solely on basic types, pointers, and dynamic memory functions.

TR

İleri düzey C programlamada, çok boyutlu veri yapıları için dinamik bellek yönetiminde ustalaşmak, özellikle sabit boyutlu dizilerin yetersiz kaldığı durumlarda çok önemlidir. Bu zorluk, yalnızca işaretçiler ve dinamik bellek tahsisi kullanarak, genellikle bir veri 'küpü' olarak kavramsallaştırılan üç boyutlu (3B) bir tamsayı dizisi oluşturmaya ve işlemeye odaklanmaktadır.

İlk boyutları `D1 x D2 x D3` olan dinamik bir 3B tamsayı dizisi tahsis etmeniz istenmektedir. Bu, en dıştaki işaretçinin 2B düzlemlere yönelik işaretçi dizisine, her birinin 1B satırlara yönelik işaretçi dizisine ve nihayetinde tamsayı dizilerine işaret ettiği bir 'işaretçinin işaretçisinin işaretçisi' (`int***`) yapısı gerektirir. Tahsisten sonra, başarılı veri depolama ve erişimi göstermek için küp belirli bir desenle başlatılmalıdır. Belleği her seviyede tahsis etmek ve diziyi değerlerle doldurmak için iç içe döngüler kullanmanız, `malloc` ve `realloc` sonuçlarını dikkatlice dönüştürmeniz gerekecektir.

Temel zorluk, sonraki bir yeniden boyutlandırma işleminden kaynaklanmaktadır. Boyutlardan birini (örneğin, `D1`) yeni, daha büyük bir `D1_new` boyutuna genişletmelisiniz. Bu, en dıştaki boyut için `realloc`'un dikkatli kullanımını gerektirir. Önemli olarak, `realloc` bloğu yerinde genişletemezse, bloğun tamamını yeni bir bellek konumuna taşıyabilir, bu nedenle temel işaretçinizi (`int***`) güncellemeniz gerekir. Yeni eklenen 'düzlemler' (veya hangi boyutu genişlettiğinize bağlı olarak satırlar/sütunlar) için, ilgili dahili 2B ve 1D dizileri tahsis etmeli ve elemanlarını başlatmalısınız. Bu işlem, `realloc`'un iç içe dinamik tahsislerle nasıl etkileşime girdiğini anlamanızı test eder ve geçiş sırasında sızıntıları veya geçersiz erişimleri önlemek için, her seviyede `malloc` ve `realloc` başarısızlıkları için sağlam hata denetimi de dahil olmak üzere hassas bellek yönetimi gerektirir.

Tüm işlemlerden sonra, 3B dizi için tahsis edilen tüm bellek segmentlerini doğru bir şekilde serbest bırakmalısınız. Bu, önce en içteki blokları, ardından ara blokları ve son olarak en dıştaki bloğu serbest bırakmayı içerir ve hiçbir bellek sızıntısının oluşmamasını sağlar. Çözüm, `struct`, `typedef` veya herhangi bir dosya I/O işlemini kesinlikle kullanmamalı, yalnızca temel türlere, işaretçilere ve dinamik bellek işlevlerine dayanmalıdır.