EN

You are tasked with managing a collection of dynamic integer streams without the aid of `struct` or `typedef` declarations. This problem challenges your understanding of raw pointer manipulation, multi-level dynamic memory allocation, and efficient memory management.

Your program must maintain a central collection, which is a dynamic array of pointers (`int**`). Each pointer in this collection, in turn, points to a single, contiguous memory block representing an individual data stream. The crucial detail is how each stream's data and its size are stored: the *first integer* within each stream's memory block *must* store the total count of subsequent integer data elements for that stream. The actual data elements begin immediately after this size indicator (i.e., at `stream_ptr[1]`, `stream_ptr[2]`, and so on, up to `stream_ptr[count]`). This design forces you to use pointer arithmetic and careful casting to access both the size and the data of each stream.

Implement a function `aggregate_and_transform_streams` that takes a pointer to your stream collection (`int***`), a pointer to its current size (`int*`), and an integer `filter_value`. This function must perform the following complex operation: it should identify all streams whose *first data element* (located at index 1 of the stream's memory block) is strictly less than `filter_value`. All identified streams must then be *concatenated* into a single new stream. The original identified streams are to be removed from the collection (and their memory freed), and this newly formed, aggregated stream should be added to the *end* of the collection. The relative order of any *remaining* streams (those not meeting the filter criterion) within the collection must be preserved. Your solution must meticulously handle all dynamic memory allocations, reallocations, and deallocations to prevent memory leaks or invalid accesses. Consider edge cases such as empty collections, no streams meeting the filter criteria, or all streams meeting the criteria.

TR

Herhangi bir `struct` veya `typedef` bildirimi kullanmadan dinamik tamsayı akışları koleksiyonunu yönetmeniz isteniyor. Bu problem, ham işaretçi manipülasyonu, çok seviyeli dinamik bellek tahsisi ve etkili bellek yönetimindeki anlayışınızı sınar.

Programınız, işaretçi koleksiyonlarından oluşan merkezi bir dinamik dizi (`int**`) tutmalıdır. Bu koleksiyondaki her işaretçi, sırasıyla, tek bir bitişik bellek bloğunu gösterir ve bu blok bireysel bir veri akışını temsil eder. Her akışın verilerinin ve boyutunun nasıl saklandığı kritik bir detaydır: Her akışın bellek bloğundaki *ilk tamsayı*, o akış için sonraki tamsayı veri elemanlarının toplam sayısını depolamalıdır. Gerçek veri elemanları bu boyut göstergesinden hemen sonra başlar (yani, `stream_ptr[1]`, `stream_ptr[2]` ve bu şekilde `stream_ptr[count]`'a kadar). Bu tasarım, hem boyuta hem de her akışın verisine erişmek için işaretçi aritmetiği ve dikkatli tip dönüşümü kullanmanızı gerektirir.

Akış koleksiyonunuza bir işaretçi (`int***`), mevcut boyutuna bir işaretçi (`int*`) ve bir tamsayı `filter_value` alan `aggregate_and_transform_streams` adlı bir fonksiyon uygulayın. Bu fonksiyon aşağıdaki karmaşık işlemi gerçekleştirmelidir: akışın *ilk veri elemanı* (akışın bellek bloğunun 1. indeksinde bulunan) kesinlikle `filter_value`'dan küçük olan tüm akışları belirlemelidir. Belirlenen tüm akışlar daha sonra *tek bir yeni akışta birleştirilmelidir*. Orijinal belirlenen akışlar koleksiyondan çıkarılmalı (ve bellekleri serbest bırakılmalı) ve bu yeni oluşturulan, birleştirilmiş akış koleksiyonun *sonuna* eklenmelidir. Koleksiyon içinde kalan (filtreleme kriterini karşılamayan) akışların göreceli sırası korunmalıdır. Çözümünüz, bellek sızıntılarını veya geçersiz erişimleri önlemek için tüm dinamik bellek tahsislerini, yeniden tahsislerini ve serbest bırakma işlemlerini titizlikle yönetmelidir. Boş koleksiyonlar, filtreleme kriterlerini karşılayan hiçbir akış olmaması veya tüm akışların kriterleri karşılaması gibi uç durumları göz önünde bulundurun.