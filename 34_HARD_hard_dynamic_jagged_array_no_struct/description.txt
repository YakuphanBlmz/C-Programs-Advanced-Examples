EN

This problem challenges you to implement a robust and flexible "jagged" two-dimensional array (an array of arrays where each inner array can have a different size) purely using C pointers and dynamic memory allocation. The primary difficulty stems from the strict constraint that you *cannot* use `struct`s, `typedef`s, or file I/O. This forces a low-level, manual approach to memory layout and management.

To achieve this, each "row" in your jagged array must be represented as a single, contiguous block of dynamically allocated memory. Within this block, the very first `sizeof(int)` bytes must store the total number of integers in that particular row. Immediately following this size indicator, the actual integer data for the row should be stored. The main "jagged array" itself will be a dynamically allocated array of `int*` pointers, where each `int*` points to one of these specially formatted row blocks. You will need to manage the capacity of this outer array, dynamically resizing it using `realloc` as rows are added or removed.

Your solution must provide a set of functions to manage this dynamic jagged array. These functions include initializing the array, adding new rows (which may require resizing the main array and allocating memory for the row's data and size metadata), removing existing rows (which requires freeing the row's memory, shifting subsequent rows, and potentially shrinking the main array), printing the contents of the array by correctly interpreting the row's internal size information, and finally, completely freeing all dynamically allocated memory. The heavy reliance on `int**` and `int***` for parameter passing and internal logic, coupled with manual memory layout and absence of structured types, makes this a genuinely hard pointer challenge.

TR

Bu problem, tamamen C işaretçileri ve dinamik bellek yönetimi (malloc, free, realloc) kullanarak sağlam ve esnek bir "düzensiz" iki boyutlu dizi (her bir iç dizinin farklı boyutlarda olabileceği bir diziler dizisi) uygulamanızı zorlamaktadır. Problemin temel zorluğu, `struct`, `typedef` veya dosya I/O kullanamama kısıtlamasından gelmektedir. Bu kısıtlama, bellek düzeni ve yönetimine düşük seviyeli, manuel bir yaklaşım gerektirmektedir.

Bu yapıyı oluşturmak için, düzensiz dizinizdeki her bir "satır", tek ve bitişik bir dinamik olarak ayrılmış bellek bloğu olarak temsil edilmelidir. Bu blok içinde, ilk `sizeof(int)` bayt, o satırdaki toplam tamsayı sayısını depolamalıdır. Bu boyut göstergesinin hemen ardından, satırın gerçek tamsayı verileri depolanmalıdır. Ana "düzensiz dizi"nin kendisi, dinamik olarak ayrılmış bir `int*` işaretçileri dizisi olacaktır; burada her bir `int*`, bu özel biçimlendirilmiş satır bloklarından birini işaret edecektir. Satırlar eklendikçe veya kaldırıldıkça ana dizinin kapasitesini dinamik olarak `realloc` kullanarak yönetmeniz gerekecektir.

Çözümünüz, bu dinamik düzensiz diziyi yönetmek için bir dizi fonksiyon sağlamalıdır. Bu fonksiyonlar arasında diziyi başlatma, yeni satırlar ekleme (ana diziyi yeniden boyutlandırmayı ve satırın verileri ile boyut meta verileri için bellek ayırmayı gerektirebilir), mevcut satırları kaldırma (satırın belleğini boşaltmayı, sonraki satırları yukarı kaydırmayı ve potansiyel olarak ana diziyi küçültmeyi gerektirir), satırın dahili boyut bilgisini doğru bir şekilde yorumlayarak dizinin içeriğini yazdırma ve son olarak, dinamik olarak ayrılan tüm belleği tamamen serbest bırakma bulunmaktadır. Parametre geçişi ve dahili mantık için `int**` ve `int***`'e yoğun bağımlılık, manuel bellek düzeni ve yapılandırılmış türlerin yokluğu ile birleştiğinde, bu problemi gerçekten zorlu bir işaretçi mücadelesi haline getirmektedir.