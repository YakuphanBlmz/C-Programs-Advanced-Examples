EN

You are tasked with implementing a sophisticated dynamic memory management system in C, without the aid of `struct` or `typedef`. Your primary goal is to manage a 'jagged' two-dimensional array of integers, where both the number of rows and the capacity of each individual row can expand dynamically. This requires meticulous handling of pointers to pointers (`int**`) and parallel arrays to track meta-information.

Specifically, you need to simulate a system that manages multiple independent lists of integers. The entire collection of these lists (the 'rows') must be dynamically resizable. Furthermore, each individual list (a 'row') must also be dynamically resizable, growing as more integers are added to it. Since `struct` is forbidden, you will need to maintain separate, dynamically allocated arrays for the actual data (`int**`), the current number of elements in each row (`int*`), and the allocated capacity for each row (`int*`). These three arrays must be kept in sync, especially during reallocations.

Your program should demonstrate the following: initial allocation for a certain number of rows and an initial capacity for each row, adding elements to specific rows and triggering `realloc` for that row's underlying array when its capacity is reached, and adding new rows which may trigger `realloc` for the main `int**` array and its parallel metadata arrays when the total row capacity is exceeded. Finally, a complete and correct deallocation strategy for all dynamically allocated memory is crucial to prevent memory leaks. The solution must strictly use `malloc`, `realloc`, and `free` for all memory operations, and must not use `struct`, `typedef`, or file I/O.

TR

C dilinde, `struct` veya `typedef` kullanmadan gelişmiş bir dinamik bellek yönetim sistemi uygulamanız isteniyor. Bir 'girintili' (jagged) iki boyutlu tamsayı dizisini yönetmek temel görevinizdir; burada hem satır sayısı hem de her bir satırın kapasitesi dinamik olarak genişleyebilir. Bu, işaretçinin işaretçilerine (`int**`) ve meta bilgileri izlemek için paralel dizilere titiz bir şekilde yaklaşmayı gerektirir.

Özellikle, birden fazla bağımsız tamsayı listesini yöneten bir sistemi simüle etmeniz gerekmektedir. Bu listelerin tüm koleksiyonu ('satırlar') dinamik olarak yeniden boyutlandırılabilir olmalıdır. Ayrıca, her bir bağımsız liste ('satır') da dinamik olarak yeniden boyutlandırılabilir olmalı ve daha fazla tamsayı eklendikçe büyümelidir. `struct` yasak olduğundan, gerçek veriler (`int**`), her satırdaki mevcut eleman sayısı (`int*`) ve her satır için ayrılan kapasite (`int*`) için ayrı, dinamik olarak tahsis edilmiş diziler tutmanız gerekecektir. Bu üç dizi, özellikle yeniden tahsisler sırasında senkronize kalmak zorundadır.

Programınız aşağıdakileri göstermelidir: belirli sayıda satır için başlangıç tahsisi ve her satır için başlangıç kapasitesi; belirli satırlara eleman ekleme ve kapasitesi dolduğunda o satırın altındaki dizinin `realloc` işlemini tetikleme; ve toplam satır kapasitesi aşıldığında ana `int**` dizisi ve paralel meta veri dizileri için `realloc` işlemini tetikleyebilecek yeni satırlar ekleme. Son olarak, tüm dinamik olarak tahsis edilmiş bellek için eksiksiz ve doğru bir serbest bırakma stratejisi, bellek sızıntılarını önlemek için çok önemlidir. Çözüm, tüm bellek işlemleri için kesinlikle `malloc`, `realloc` ve `free` kullanmalı ve `struct`, `typedef` veya dosya G/Ç içermemelidir.